\section{Method}
\subsection{Example Systems}
\label{sec:eg-sys}

When testing our model we employ a number of example systems to test various features of the integrator, in different physical scenarios. Each of these is also associated with a specific embedding.

\subsubsection{Damped Forced Harmonic Oscillators}

A damped harmonic oscillator is one of the simplest non-conservative systems which we can model having a non-conservative Lagrangian given by\cite{galleyPrincipleStationaryNonconservative2014},

\begin{equation}
\begin{aligned}
  \Lambda &= L - K \\
  L &= \frac12 m\dot\vbq^2 - \frac12 m\dot\vbq -  \\
  K &= - \lambda\vbq_- \cdot \dot \vbq_+ + \vbq_- \cdot \vb{F}(t)
\end{aligned}
\end{equation}

for a system with mass $m$, spring constant $k$, damping constant $\lambda$ and time dependent force $\vb{F}(t)$. This corresponds with the standard equation of motion,

\begin{equation}
  m \ddot{\vb x} + \lambda \ddot{\vb x} + k \vb x = \vb F(t).
\end{equation}

\subsubsection{PRD}

\subsubsection{Large coupled springs}

\subsection{Improvements to the \SI{} and their Physical Applications}

Initially the existing \texttt{slimpletic} codebase \cite{originalCode}, the \orgimpl{}, was rewritten using the JAX framework, the \updimpl{}. We chose two key metrics, run-time duration and accuracy, to judge our model against the \orgimpl{} and RK4, a well known non-variational integrator \todo{we should have referenced this already}. 

First to ensure that we maintained the error bounds expected for our model (as per \sref{sec:intro-si}) we generated graphs of fractional energy and momentum error for Runge-Kutta, the \orgimpl{}, and the \updimpl{}.

Next we create three test-cases to measure performance of the integrator and its consequences on experimental capability. These were,

\begin{enumerate}
	\item Modelling systems for different timespans varying the number of iterations performed by the integrator.
	\item Modelling the same system across different orders of integration $r$ to determine how the order of our method effects the performance.
	\item Modelling a collection of similar systems, across different initial conditions.
\end{enumerate}

The first two of these are designed to test the scaling behaviours of our model to provide insight into its applicability to larger systems, the third acting as a more realistic test case of its use in actual experimental physics. Finally we simulate a large coupled spring system to show the applicability of the observed scaling laws to physical experiments.

\subsection{Applications to Loss Functions}

Taking this \updimpl{} we then explore its different uses as a loss function for physical systems. To start we consider only the form of the loss function, as well as the embedding function to use.

\todo{I probably want a table for embeddings we use}

While these are distinct components of a learning system, they are heavily linked as ideally we would define the physical components of our loss function primarily in terms of the trajectories, rather than the values of the embedding vector itself. Hence the embedding function and slimpletic integrator must be chained together before the physical loss component to provide it with the trajectories.\todo{This feels like a nice place for a data flow diagram}

We consider a number of choices for these two functions comparing their behaviour near known minima, and testing for convexity by randomly sample pairs of points in the embedding space determine if the inequality,

\begin{equation}
  f\left(\frac{x+y}{2}\right) \le \frac{f(x)+f(y)}{2}
\end{equation}

holds near known minima points. \textbf{OR} To test the value of the second derivative of the function.

We also explore these systems through applying an optimiser directly to the space to determine their suitability.

\todo{Again wouldn't it be cool to talk about symmetries here}

\subsection{Loss Function in the Training of Neural Networks}

Finally we apply various loss function and embedding choices to a stand-in neural network observing how the loss varies across training, and the correctness of the outputs.

This involves generating large datasets of different physical systems within the domain of the chosen embedding.

\todo{TALK ABOUT LSTMS}

